/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/



import { useEffect, useRef, useState } from "react";
import { useGLTF, useAnimations, useKeyboardControls } from "@react-three/drei";
import { useFrame, useThree } from "@react-three/fiber";
import { useGameStore } from '../stores/useGameStore';
import { RigidBody } from "@react-three/rapier";
import { Controls } from '../utils/constants';
import * as THREE from "three";

/**
 * 
 * Action types: 
 *  sit to stand
    sit to type
    siting idle
    stand to sit
    stand_to_type
    standing idle
    type to sit
    type_to_stand/
    typing
    walk
 */
export function Avatar() {
  const group = useRef();
  const body = useRef()

  const { nodes, materials, animations } = useGLTF("/model/avatar.glb");
  const { actions } = useAnimations(animations, group);

  const [currentAction, setCurrentAction] = useState('standing idle')

  const { controls, camera } = useThree()
  const [subscribeKeys, getKeys] = useKeyboardControls()


  useEffect(() => {
    const unsubscribeJump = subscribeKeys(
      (state) => state.jump,
      (value) => {
        if (value) {
          body.current.applyImpulse({ x: 0, y: 10.0, z: 0 })
        }
      }
    )

    return () => {
      unsubscribeJump()
    }
  }, [subscribeKeys])


  useEffect(() => {
    actions[currentAction].reset().fadeIn(0.5).play()

    return () => {
      actions[currentAction].fadeOut(0.5)
    }
  }, [currentAction, actions])

  useEffect(() => {
    if (controls && camera) {
      const cameraPosition = new THREE.Vector3(
        body.current.translation().x - 4.0,
        body.current.translation().y + 3.0,
        body.current.translation().z
      )
      const target = new THREE.Vector3(
        body.current.translation().x,
        body.current.translation().y + 2.0,
        body.current.translation().z
      )

      camera.position.copy(cameraPosition)
      controls.target.copy(target)
    }
  }, [controls, camera])


  useFrame((state, delta) => {
    const keysPressed = getKeys()
    const isDirectionPressed = Object.keys(Controls).some(key => keysPressed[key])
    let action = isDirectionPressed ? 'walk' : 'standing idle'

    setCurrentAction(action)
    updateAvatarMovement(keysPressed, action, state, delta)
  })

  const updateAvatarMovement = (keysPressed, action, state, delta) => {
    const avatarPosition = body.current.translation()

    if (action === 'walk') {
      const axisYOfRotation = new THREE.Vector3(0, 1, 0);

      // calculate towards camera direction
      const angleYCameraDirection = Math.atan2(
        avatarPosition.x - state.camera.position.x,
        avatarPosition.z - state.camera.position.z
      )

      // diagonal movement angle offset
      const directionAngleOffset = getDirectionAngleOffset(keysPressed)

      // rotate model
      const quartenionRotation = new THREE.Quaternion().setFromAxisAngle(axisYOfRotation, angleYCameraDirection + directionAngleOffset)
      body.current.setRotation(quartenionRotation)

      // calculate direction
      const walkDirection = new THREE.Vector3()
      state.camera.getWorldDirection(walkDirection)
      walkDirection.y = 0
      walkDirection.applyAxisAngle(axisYOfRotation, directionAngleOffset)
      walkDirection.normalize()

      // move model
      const impluseStrength = 8.0 * delta
      const impulse = { x: impluseStrength * walkDirection.x, y: 0, z: impluseStrength * walkDirection.z }
      body.current.applyImpulse(impulse)


      // move camera
      const updatedCameraTarget = new THREE.Vector3()
      updatedCameraTarget.copy(avatarPosition)
      updatedCameraTarget.addScaledVector(walkDirection, 0.02)


      const updatedCameraPosition = new THREE.Vector3()
      updatedCameraPosition.copy(avatarPosition)
      updatedCameraPosition.addScaledVector(walkDirection, 0.02)

      // state.camera.position.copy(updatedCameraPosition)
      // state.controls.target = updatedCameraTarget
      state.camera.updateProjectionMatrix()
      state.controls.update()
    }
  }

  const getDirectionAngleOffset = ({ forward, back, left, right }) => {
    var directionOffset = 0 // w

    if (forward) {
      if (left) {
        directionOffset = Math.PI / 4 // w+a
      } else if (right) {
        directionOffset = - Math.PI / 4 // w+d
      }
    } else if (back) {
      if (left) {
        directionOffset = Math.PI / 4 + Math.PI / 2 // s+a
      } else if (right) {
        directionOffset = -Math.PI / 4 - Math.PI / 2 // s+d
      } else {
        directionOffset = Math.PI // s
      }
    } else if (left) {
      directionOffset = Math.PI / 2 // a
    } else if (right) {
      directionOffset = - Math.PI / 2 // d
    }

    return directionOffset
  }

  return (
    <RigidBody
      ref={body}
      colliders='hull'
      type='dynamic'
      position={[-2.789, 3.465, -4.411]}
      rotation={[0, 1.408, 0]}
      lockRotations
      enabledRotations={[false, true, false]}
      linearDamping={4.0}
      gravityScale={2.0}
      canSleep={false}
    >
      <group
        ref={group}
        name="Character"
      >
        <skinnedMesh
          name="Wolf3D_Avatar"
          geometry={nodes.Wolf3D_Avatar.geometry}
          material={materials.Wolf3D_Avatar}
          skeleton={nodes.Wolf3D_Avatar.skeleton}
        />
        <skinnedMesh
          name="Wolf3D_Avatar_Transparent"
          geometry={nodes.Wolf3D_Avatar_Transparent.geometry}
          material={materials.Wolf3D_Avatar_Transparent}
          skeleton={nodes.Wolf3D_Avatar_Transparent.skeleton}
        />
        <primitive object={nodes.Hips} />
      </group>
    </RigidBody>
  );
}

useGLTF.preload("/model/avatar.glb");
