/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/



import { useEffect, useRef, useState } from "react";
import { useGLTF, useAnimations } from "@react-three/drei";
import { useFrame, useThree } from "@react-three/fiber";
import { RigidBody, quat } from "@react-three/rapier";
import { Controls, AnimationAction } from '@/utils/constants';
import * as THREE from "three";
import gsap from "gsap";
import { models } from '@/assets/index.js'
import { useGameStore } from "@/stores/useGameStore";

/**
 * 
 * Action types: 
 *  sit to stand
    sit to type
    siting idle
    stand to sit
    stand_to_type
    standing idle
    type to sit
    type_to_stand/
    typing
    walk
 */
export function Avatar({
  getKeysPressed
}) {
  const group = useRef();
  const body = useRef()
  const currentCameraPosition = useRef(new THREE.Vector3())
  const currentCameraLookAt = useRef(new THREE.Vector3())
  const isOnTheGround = useRef(true)

  const isActive = useGameStore((state) => state.isActive)
  const isInteractionReady = useGameStore((state) => state.isInteractionReady)
  const toggleInteraction = useGameStore((state) => state.toggleInteraction)

  const [currentAction, setCurrentAction] = useState(AnimationAction.typing)
  const { nodes, materials, animations } = useGLTF(models.avatar);
  const { actions, mixer } = useAnimations(animations, group);

  const { controls, camera } = useThree()

  useEffect(() => {
    if (isActive) {
      const newBodyPosition = { x: -2.0, y: 0, z: 0 }
      body.current.applyImpulse(newBodyPosition)
      setCurrentAction(AnimationAction.type_to_stand)
    }
  }, [isActive])

  useEffect(() => {
    const action = actions[currentAction]
    let animationFinished;

    if (currentAction === AnimationAction.type_to_stand) {
      animationFinished = () => {
        const bodyPosition = body.current.translation()
        const bodyRotation = body.current.rotation()

        const idealOffSet = calculateIdealOffSet(bodyPosition, bodyRotation)
        const idealLookAt = calculateIdealLookAt(bodyPosition, bodyRotation)

        currentCameraPosition.current = idealOffSet;
        currentCameraLookAt.current = idealLookAt

        gsap.to(camera.position, {
          duration: 2.0,
          ease: 'expo.out',
          x: idealOffSet.x,
          y: idealOffSet.y,
          z: idealOffSet.z,
          onUpdate: () => {
            controls.target.copy(idealLookAt)
          },
          onComplete: () => {
            toggleInteraction()
          }
        })
      }

      mixer.addEventListener('finished', animationFinished)

      action.clampWhenFinished = true
      action
        .reset()
        .setLoop(THREE.LoopOnce, 1)
        .fadeIn(0.5)
        .play()
    } else {
      action.reset().fadeIn(0.5).play()
    }

    return () => {
      mixer.removeEventListener('finished', animationFinished)
      action.fadeOut(0.5)
    }
  }, [currentAction, actions, mixer])

  useEffect(() => {
    if (controls && camera) {
      const bodyPosition = body.current.translation();

      const cameraPosition = new THREE.Vector3(
        bodyPosition.x - 10.0,
        bodyPosition.y + 3.0,
        bodyPosition.z - 1.0
      )
      const target = new THREE.Vector3(
        bodyPosition.x,
        bodyPosition.y + 2.0,
        bodyPosition.z
      )

      // const cameraPosition = new THREE.Vector3(
      //   100, 80, 0
      // )
      // const target = new THREE.Vector3(100, 0, 0)

      // camera.position.copy(cameraPosition)
      // controls.target.copy(target)

    }
  }, [controls, camera])


  useFrame((state, delta) => {
    const keysPressed = getKeysPressed()

    if (isActive && isInteractionReady) {
      updateAvatarMovement(keysPressed, delta)
      updateCameraControls(body.current.translation(), body.current.rotation(), delta)
    }
  })

  const calculateIdealLookAt = (bodyPosition, bodyRotation) => {
    const idealLookAt = new THREE.Vector3(0.0, 2.0, 0)
    idealLookAt.applyQuaternion(bodyRotation)
    idealLookAt.add(bodyPosition)
    return idealLookAt
  }

  const calculateIdealOffSet = (bodyPosition, bodyRotation) => {
    const idealOffSet = new THREE.Vector3(0, 3, -4)
    idealOffSet.applyQuaternion(bodyRotation)
    idealOffSet.add(bodyPosition)
    return idealOffSet
  }

  const updateCameraControls = (bodyPosition, bodyRotation, delta) => {
    const idealOffSet = calculateIdealOffSet(bodyPosition, bodyRotation)
    const idealLookAt = calculateIdealLookAt(bodyPosition, bodyRotation)

    const t = 1.0 - Math.pow(0.001, delta)
    currentCameraPosition.current.lerp(idealOffSet, t)
    currentCameraLookAt.current.lerp(idealLookAt, t)

    gsap.to(camera.position, {
      duration: delta,
      x: currentCameraPosition.current.x,
      y: currentCameraPosition.current.y,
      z: currentCameraPosition.current.z,
      onUpdate: () => {
        controls.target.copy(currentCameraLookAt.current)
      }
    })
  }

  const move = (keysPressed, delta) => {
    const { forward, left, right, back } = keysPressed

    const axisYOfRotation = new THREE.Vector3(0, 1, 0);

    // horizontal move
    const walkDirection = new THREE.Vector3()
    camera.getWorldDirection(walkDirection)
    walkDirection.y = 0
    walkDirection.normalize()
    const impluseStrength = 10.0 * delta
    const impulse = new THREE.Vector3(impluseStrength * walkDirection.x, 0, impluseStrength * walkDirection.z)

    if (forward) {
      body.current.applyImpulse(impulse)
    } else if (back) {
      body.current.applyImpulse(impulse.negate())
    }

    // rotation
    let avatarRotation = quat(body.current.rotation())
    let rotationStrength = 0.5 * delta

    if (left) {
      let quartenionRotation = new THREE.Quaternion().setFromAxisAngle(axisYOfRotation, Math.PI * rotationStrength)
      avatarRotation = avatarRotation.multiply(quartenionRotation)
      body.current.setRotation(avatarRotation)
    } else if (right) {
      let quartenionRotation = new THREE.Quaternion().setFromAxisAngle(axisYOfRotation, - Math.PI * rotationStrength)
      avatarRotation = avatarRotation.multiply(quartenionRotation)
      body.current.setRotation(avatarRotation)
    }
  }

  const updateAvatarMovement = (keysPressed, delta) => {
    const isDirectionPressed = (Object.keys(Controls).some(key => keysPressed[key] && key !== Controls.jump.name))

    if (isOnTheGround.current) {
      // check jump 
      if (keysPressed.jump) {
        isOnTheGround.current = false
        body.current.applyImpulse({ x: 0, y: 10.0, z: 0 })
      }

      // check move
      if (isDirectionPressed) {
        setCurrentAction(AnimationAction.walk)
        move(keysPressed, delta)
      } else {
        setCurrentAction(AnimationAction.standing_idle)
      }
    } else {
      // allow horizontal move
      setCurrentAction(AnimationAction.jump)
      if (isDirectionPressed) move(keysPressed, delta)
    }
  }

  const updateOnTheGroundStatus = (maxContactForceDirection) => {
    if (maxContactForceDirection.y > maxContactForceDirection.x && maxContactForceDirection.y > maxContactForceDirection.z) {
      isOnTheGround.current = true
    }
  }

  return (
    <RigidBody
      ref={body}
      colliders='hull'
      type='dynamic'
      position={[-2.789, 3.465, -4.411]}
      rotation={[0, 1.408, 0]}
      lockRotations
      enabledRotations={[false, true, false]}
      linearDamping={5.0}
      angularDamping={5.0}
      gravityScale={2.0}
      canSleep={false}
      onContactForce={(payload) => updateOnTheGroundStatus(payload.maxForceDirection)}
    >
      <group
        ref={group}
        name="Character"
      >
        <skinnedMesh
          name="Wolf3D_Avatar"
          geometry={nodes.Wolf3D_Avatar.geometry}
          material={materials.Wolf3D_Avatar}
          skeleton={nodes.Wolf3D_Avatar.skeleton}
        />
        <skinnedMesh
          name="Wolf3D_Avatar_Transparent"
          geometry={nodes.Wolf3D_Avatar_Transparent.geometry}
          material={materials.Wolf3D_Avatar_Transparent}
          skeleton={nodes.Wolf3D_Avatar_Transparent.skeleton}
        />
        <primitive object={nodes.Hips} />
      </group>
    </RigidBody>
  );
}

useGLTF.preload(models.avatar);
